---
title: "REUSED - CRYPTO - EGCERT CTF 2025"
date: 2025-05-28
categories: [CHALLENGES, REUSED - CRYPTO - EGCERT CTF 2025]
tags: [CHALLENGES, CTF] 
---

Hello! In this write-up, I’ll be solving the “Reused” challenge from **EGCTF 2025** - a challenge that highlights a subtle but critical flaw in cryptographic systems: **key reuse in AES-CBC mode.**

In this write-up, I’ll demonstrate how reusing the same encryption key across multiple operations can open the door to serious vulnerabilities — specifically, how it enables attackers to exploit predictable patterns and ultimately recover sensitive data.


## Challenge source code analysis
We’re given the source code for the challenge, so the first step is to analyze it closely and identify the vulnerability in the implementation of AES-CBC encryption.

```python
import json
from Crypto.Cipher import AES
from config import FLAG, KEY


def aes_crypt(data, mode):
    return AES.new(KEY, AES.MODE_CBC, KEY).encrypt(data) if mode == "enc" else AES.new(KEY, AES.MODE_CBC, KEY).decrypt(data)

while True:
    try:
        user_input = json.loads(input(">>> "))
        action = user_input.get("type")
        response = {}

        if action == "enc":
            data = bytes.fromhex(user_input.get("plaintext", ""))
            response = {"status": "success", "ciphertext": aes_crypt(data, "enc").hex()}
        
        elif action == "dec":
            data = bytes.fromhex(user_input.get("ciphertext", ""))
            response = {"status": "success", "plaintext": aes_crypt(data, "dec").hex()}
        
        elif action == "verify":
            user_key = bytes.fromhex(user_input.get("key", ""))
            if user_key == KEY:
                response = {"status": "success", "flag": FLAG.hex()}
            else:
                response = {"status": "error", "message": "Try Again !!"}
        
        else:
            response = {"status": "error", "message": "Invalid input type"}
        
    except (json.JSONDecodeError, ValueError):
        response = {"status": "error", "message": "Invalid input"}

    print(json.dumps(response))
```

The challenge script implements AES encryption and decryption using the AES-CBC mode. It allows three actions via JSON input:

- **"enc"**: Encrypts 32 bytes of user-supplied plaintext.
- **"dec"**: Decrypts user-supplied ciphertext.
- **"verify"**: Verifies if the attacker has recovered the secret encryption key.


## Spotting the bug.

At the heart of the vulnerability is this line:
```python 
AES.new(KEY, AES.MODE_CBC, KEY)
```

This line initializes **both the AES key and IV** with the same static KEY value. In AES-CBC, **reusing the key as the IV** is a serious cryptographic flaw. The IV should be random and unique per encryption, but in this implementation, it's predictable and constant. This opens the door to a **key recovery attack** by exploiting the deterministic nature of CBC mode when given controlled plaintext.






