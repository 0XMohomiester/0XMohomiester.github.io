---
title: "REUSED - CRYPTO - EGCTF 2025"
date: 2025-05-28
categories: [CHALLENGES, REUSED - CRYPTO - EGCERT CTF 2025]
tags: [CHALLENGES, CTF] 
---

Hello! In this write-up, I’ll be solving the **Reused** challenge from **EGCTF 2025** - a challenge that highlights a subtle but critical flaw in cryptographic systems: **key reuse in AES-CBC mode.**

In this write-up, I’ll demonstrate how reusing the same encryption key across multiple operations can open the door to serious vulnerabilities — specifically, how it enables attackers to exploit predictable patterns and ultimately recover sensitive data.


## Challenge source code analysis
We’re given the source code for the challenge, so the first step is to analyze it closely and identify the vulnerability in the implementation of AES-CBC encryption.

```python
import json
from Crypto.Cipher import AES
from config import FLAG, KEY


def aes_crypt(data, mode):
    return AES.new(KEY, AES.MODE_CBC, KEY).encrypt(data) if mode == "enc" else AES.new(KEY, AES.MODE_CBC, KEY).decrypt(data)

while True:
    try:
        user_input = json.loads(input(">>> "))
        action = user_input.get("type")
        response = {}

        if action == "enc":
            data = bytes.fromhex(user_input.get("plaintext", ""))
            response = {"status": "success", "ciphertext": aes_crypt(data, "enc").hex()}
        
        elif action == "dec":
            data = bytes.fromhex(user_input.get("ciphertext", ""))
            response = {"status": "success", "plaintext": aes_crypt(data, "dec").hex()}
        
        elif action == "verify":
            user_key = bytes.fromhex(user_input.get("key", ""))
            if user_key == KEY:
                response = {"status": "success", "flag": FLAG.hex()}
            else:
                response = {"status": "error", "message": "Try Again !!"}
        
        else:
            response = {"status": "error", "message": "Invalid input type"}
        
    except (json.JSONDecodeError, ValueError):
        response = {"status": "error", "message": "Invalid input"}

    print(json.dumps(response))
```

The challenge script implements AES encryption and decryption using the AES-CBC mode. It allows three actions via JSON input:

- **enc**: Encrypts 32 bytes of user-supplied plaintext.
- **dec**: Decrypts user-supplied ciphertext.
- **verify**: Verifies if the attacker has recovered the secret encryption key.


## Spotting the bug.

At the heart of the vulnerability is this line:
```python 
AES.new(KEY, AES.MODE_CBC, KEY)
```

This line initializes **both the AES key and IV** with the same static KEY value. In AES-CBC, **reusing the key as the IV** is a serious cryptographic flaw. The IV should be random and unique per encryption, but in this implementation, it's predictable and constant. This opens the door to a **[reused key attack](https://en.wikipedia.org/wiki/Stream_cipher_attacks)** by exploiting the deterministic nature of CBC mode when given controlled plaintext.


## Manuel Exploiting 

Now that we’ve identified the core vulnerability, let’s manually exploit it.

AES in CBC **(Cipher Block Chaining)** mode processes data in **16-byte blocks**. Each block of plaintext is XORed with the previous ciphertext block (or the IV for the first block) before encryption. This chaining mechanism is secure only when the **IV is random** and unique for each encryption.

![IMG](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WmpqO5-4hNvJSKnsOTDZUQ.png)


Now, if we think logically based on the flawed implementation of AES where the **key is reused as the IV**, **sending 32 bytes of zeros** to the server (i.e., two AES blocks) leads to a critical weakness. In CBC mode, the first 16-byte block is XORed with the IV — which, in this case, is the same as the key. Since XORing any value with all-zero bytes returns the original value, this block effectively becomes the key itself. This "key" is then encrypted using AES with the same key, resulting in the encrypted version of the key being leaked.

```
C1 = AES_ENC(0x00 ⊕ IV) = AES_ENC(IV) = AES_ENC(KEY)
C2 = AES_ENC(0x00 ⊕ C1) = AES_ENC(C1)
```

![IMG1](https://github.com/user-attachments/assets/f6f6b0a8-8007-4696-8884-4c88487340d5)
![IMG2](https://github.com/user-attachments/assets/acfb47a0-26f0-4440-baa8-93f8be2cda91)

Then, the first ciphertext is **encryption of the key** and second ciphertext is the encryption of first ciphertext (key encrypted).

In thre second step we can send second ciphertext to the server in the addition of 16 bytes of zeros to ...  

