---
title: "DynoPIN - IOS APP challenge"
date: 2025-07-07
categories: [Mobile Security, IOS APP challenge]
tags: [Mobile Security, CTF, IOS]
---

Behind a clean interface and a 4-digit input lies a cleverly protected DynoPIN isn’t just another iOS app; it’s a trap for anyone who thinks brute force is enough.

---

### Analyze App Behavior

To begin, we installed the app on a **jailbroken iOS** device to examine its structure and interface. The application features a straightforward layout, requiring users to input a 4-digit PIN to unlock the flag.

When testing with random PINs, the app consistently rejects them, confirming that the validation logic is not trivial. This behavior suggests that reverse engineering is necessary to uncover how the PIN verification works internally.

![Screen-Shot-2025-07-07-at-2-33-27-PM.png](https://i.postimg.cc/dVvZWLBn/Screen-Shot-2025-07-07-at-2-33-27-PM.png)


### Reverse Engineering iOS App

One of the most interesting aspects of iOS application penetration testing is reverse engineering the Mach-O binary. This binary is a core component of every iOS app and contains the compiled logic written by the developer.

An iOS app's file structure within an .ipa package is organized with a specific hierarchy essentially a ZIP archive containing the app's data. The core of the app is within a folder named `.app`, which is essentially a directory disguised as a file. Inside this `.app` folder, you'll find the compiled executable file (containing the app's code which is Mach-O Binary file), Info.plist (which holds metadata like the app's name and version), and various resources like images, nib files, and localized files.

Let’s rename the file from `.ipa` to `.zip` to extract files.


![Screen-Shot-2025-06-21-at-12-38-21-PM.png](https://i.postimg.cc/fRjgV25C/Screen-Shot-2025-06-21-at-12-38-21-PM.png)

![Screen-Shot-2025-06-21-at-12-53-12-PM.png](https://i.postimg.cc/HktxxmML/Screen-Shot-2025-07-07-at-3-35-27-PM.png)


The interesting part of these files is Mach-O Binary file which contain binary logic, we can reverse engineering it using ghidra or any other reverse engineering tool.
I preferred to reverse engineer the x86_64 architecture, as it is generally easier to analyze during reverse engineering.

In Ghidra, we can search for the keyword **pin** to identify any functions or symbols related to PIN validation or the input code entered by the user.

![Screen-Shot-2025-06-21-at-1-44-30-PM.png](https://i.postimg.cc/T3wWbhJs/Screen-Shot-2025-06-21-at-1-44-30-PM.png)

We can see a `check_pin` function in `pin_checker` class that appears to be responsible for validating the PIN we entered. Great—let’s examine it in the decompilation view in Ghidra.

![Screen-Shot-2025-06-21-at-1-44-30-PM.png](https://i.postimg.cc/1tLLGgFr/Screen-Shot-2025-06-21-at-2-47-22-PM.png)

**Summary of check_pin working** :
1) Every time `check_pin` is called, it generates a new random number between 0 and 9999.
2)  Creates a string with the format `cf_%d`, where `%d` is the random number generated.
3)  This means the valid PIN changes randomly every time you call `check_pin` function.
4)  If your input matches the generated random string, it returns true, otherwise false.

Now that we understand how the application works and how the PIN is validated in the background, our goal is to make the check_pin function `return` true in order to retrieve the flag. Since the correct PIN is randomized each time, the most effective approach is to analyze the function dynamically at runtime and force it to return true—even when the user enters an incorrect PIN.

### Dynamic Analysis and Runtime Manipulation

One of the most powerful tools in dynamic analysis is **Frida**, a dynamic instrumentation toolkit that allows us to `hook` into and `modify` the behavior of functions at runtime. Using Frida, we can intercept the `check_pin` function and force it to always return true, effectively bypassing the PIN verification mechanism regardless of the input.

Let’s start with attach to the DynoPIN application using Frida.

![Screen-Shot-2025-06-21-at-3-09-24-PM.png](https://i.postimg.cc/Hs1pmY2F/Screen-Shot-2025-07-07-at-6-02-39-PM.png)


Now we can enumerate `loaded classes` using **Frida** REPL and confirm the presence of `pin_checker` class. This validates that the method we found earlier is indeed part of the app’s runtime logic. Frida provide ObjC API that we can interact and enumerate loaded classes in application, we can use `ObjC.classes` to see loaded class.

![Screen-Shot-2025-06-21-at-3-16-47-PM.png](https://i.postimg.cc/Z5SvfVm1/Screen-Shot-2025-06-21-at-3-16-47-PM.png)

we can now see that the pin_checker class loaded at this address: `0x1026e8a38`.

That’s perfect now we can search for methods inside the `pin_checker` class to capture the address of the `check_pin` function.

![Screen-Shot-2025-06-21-at-3-23-02-PM.png](https://i.postimg.cc/jqfjGPMK/Screen-Shot-2025-06-21-at-3-23-02-PM.png)

![Screen-Shot-2025-06-21-at-3-28-21-PM.png](https://i.postimg.cc/xTjWKSJ7/Screen-Shot-2025-06-21-at-3-28-21-PM.png)

Now that we’ve retrieved the memory address of the `check_pin` function, our next goal is to hook and intercept it using Frida’s Interceptor API. To simplify the process, we can write the hooking logic in a JavaScript file and load it when attaching to the application.

![Screen-Shot-2025-06-21-at-3-45-33-PM.png](https://i.postimg.cc/nhG2TXyG/Screen-Shot-2025-06-21-at-3-45-33-PM.png)

Explanation of my JS code:
1) **Get the method address** of `check_pin` from the `pin_checker` class using `.implementation`.
2) **Attach a hook** to that method using Interceptor API.
3) **In onEnter callback**, log the method name by reading `args[1]` (the selector).
4) **Also in onEnter**, extract the user-entered PIN from `args[2]` and log it.
5) **In onLeave**, log the original return value of the method.
6) **Force the function** to return true by replacing the return value with `0x1`, bypassing PIN validation.

```javascript
var addr = ObjC.classes['pin_checker']['+ check_pin:'].implementation;

Interceptor.attach(addr, {
  onEnter: function(args) {
    console.log('Function ${args[1].readUtf8String()} Called');
    var user_code = ObjC.Object(args[2]).toString();
    console.log('User Enter: ${user_code}');
  },
  onLeave: function(retval) {
    console.log('Original Return value ${retval}');
    retval.replace(ptr(0x1)); // Force return true
  }
});
```

Let’s try the script:

![Screen-Shot-2025-06-21-at-3-53-01-PM.png](https://i.postimg.cc/262gtHgT/Screen-Shot-2025-06-21-at-3-53-01-PM.png)


Thanks for reading.

Follow me on [Linkedin](https://www.linkedin.com/in/0xmohomiester/)
